/**
 *                                         ...........
 *                                 .::--==================--:..
 *                            .:-===++*#%%@@@@@@@@@@@@@%%##*+===--:.
 *                        .:-==+*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@%#*===-:
 *                     .:-==*#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%#+==-:
 *                   :-==*%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#+==-.
 *                 :==+#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#==-.
 *               :==+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#+=-.
 *             .==+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*=------=+#@@@@@@@@@@@@@@@#==-
 *            -==#@@@@@@@@@@@@@@@@@@@@%#####%@@@@@#-------------#@@@@@@@@@@@@@@@*==:
 *          .==+@@@@@@@@@@@@@@@@@@%+-:::::::--+#@@---------------=@@@@@@@@@@@@@@@%==-
 *         .==*@@@@@@@@@@@@@@@@@%=:::::::::------*%---------------#@@@@@@@@@@@@@@@@+=-
 *        :==#@@@@@@@@@@@@@@@@@*-:::::----------------------=+#######%@@@@@@@@@@@@@@*==.
 *       .==#@@@@@@@@@@@@@@@@@+---------------------------*%#+---------+%@@@@@@@@@@@@*==
 *      .==*@@@@@@@@@@@@@@@@@*----------------------------=--------------=@@@@@@@@@@@@+=-
 *      -=+@@@@@@@@@@@@@@@@@%-----------=+****+=--------------------++**#**@@@@@@@@@@@%==:
 *     :==%@@@@@@@@@@@@@@@@@*-------=###++====+*%%*-------------+#@%*+==--=+%@@@@@@@@@@#==
 *     ==*@@@@@@@@@@@@@@@@@@=-----=%#=------------*@*---------*@#+----------=@@@@@@@@@@@==:
 *    .==%@@@@@@@@@@@@@@@@@@------=-----------------#%------=@#=------------=@@@@@@@@@@@*==
 *    :==@@@@@@@@@@@@@@@@@%+-------------------=+***+%%-----#*--------------#@@@@@@@@@@@%==.
 *    -=+@@@@@@@@@@@@@@@@+---------------=+#%@%#*+===+@=-------------------#@@@@@@@@@@@@@==:
 *    -=*@@@@@@@@@@@@@@%===-----------=*%@%*=---------=#---==-----------=*@@@@@@@@@@@@@@@==:
 *    -=*@@@@@@@@@@@@@%======-------=#@@*=------------=#----+**++++++*###++%@@@@@@@@@@@@@==:
 *    -=+@@@@@@@@@@@@@=========----#@@+--------------=%=-------=++++*%*----#@@@@@@@@@@@@@==:
 *    :==@@@@@@@@@@@@#===========--+*=--------------*%=----------=**+---=*%@@@@@@@@@@@@@%==.
 *    .==%@@@@@@@@@@@#==============-------------+#%+-------=+***+-=+*#**+%@@@@@@@@@@@@@*==
 *     ==*@@@@@@@@@@@%================-----=+*###*=----=+**###*****#%#===%@@@@@@@@@@@@@@==:
 *     :==%@@@@@@@@@@@+==================-=*++=--=+**##*##**+====*#*===+@@@@@@@@@@@@@@@#==
 *      -=+@@@@@@@@@@@@+===================+*####*++==*#+=====*#*=====#@@@@@@@@@@@@@@@%==:
 *      .==*@@@@@@@@@@@@#============+*###*++=====+*##+==+*##*=====+#@@@@@@@@@@@@@@@@@+=-
 *       .==#@@@@@@@@@@@@@*==========@+=+#########*++*###*+=====+#@@@@@@@@@@@@@@@@@@@+=-
 *        :==#@@@@@@@@@@@@@@%*=======+#############**+======*#%@@@@@@@@@@@@@@@@@@@@@+==
 *         .==*@@@@@@@@@@@@@@@@%#*+===================++*%@@@@@@@@@@@@@@@@@@@@@@@@@+=-
 *          .-=+@@@@@@@@@@@@@@@@@@@@@%%#####*#####%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%==-
 *            -==#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*==:
 *             .-=+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#==-
 *               :==+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#==-.
 *                 :==+#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%*==-.
 *                   .-==*%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#+==-.
 *                      :-==*#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%#+==-.
 *                         :-===*#%@@@@@@@@@@@@@@@@@@@@@@@@@@@@%#+===-.
 *                            .:-====+*##%%@@@@@@@@@@@@%%##*+===-::.
 *                                 .::--==================--:..
 *                                          ..........
 */

/**▪  ▄.▄.▄▄▄▄.▪▄▄▄▄.▄▄▄ ▄▄▄· ▄▄.·▄ ▄▄▄▄· ▪  ▄  ▄·▄▄▄▄ .·▄▄▄▄
 *██ •█▌█▌•██ ·▀▀▄. ▀▄▄█·▐█ ▌▪██▪▐█ █▀▀█ ██ •█▌▐█ ▀▀▄▪ ▐█▪ ██
 *▐█·▐█▐▐▌ ▐█.▪▐▀▀▪▄▐▀▀▄ ██ ▄▄██▀▐█ █▀▀█·▐█·▐█▐▐▌▐▀▀▪▄·▐█· ██
 *▐█·██▐█▌ ▐█▌·▐█▄▄▌▐█•█▌▐███▌██ ▐█ █▪ █·▐█ ██▐█▌▐█▄▄▌·▐█. ██
 * █▪ ▀▪▀ •▀▀▀ .▀▀▀▀·▀ ▀• ▀▀▀· ▀ •▀ ▀• ▀  █▪ ▀ ▀ •▀▀▀▀  ▀▀▀▀▀
 * @title Interchained's iBridge contracts
 * @notice Community FOSS R&D supported by FrenChain, Kekchain, Electronero Network, Crystaleum
 * @author Interchained && Decentral && Lucas
 */

//SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

interface iSign {
    function manageSigner(address _signer, bool _status) external;
}
contract Signable is Context, iSign {
    mapping(address => bool) public signer;

    event SignerUpdated(address indexed signer, bool indexed status);

    constructor(address payable signor) {
        signer[signor] = true;
    }

    modifier onlySigners() {
        require(signer[_msgSender()], "caller must be signer");
        _;
    }

    function manageSigner(address _signer, bool _status) public virtual override onlySigners {
        signer[_signer] = _status;
        emit SignerUpdated(_signer, _status);
    }
}

contract iBridge is Signable, Ownable {
    using SafeERC20 for IERC20;

    address payable iSupport;
    address payable iVault;

    uint256 private constant BP = 10000;
    uint256 public reserves;
    uint256 public donation;
    uint256 public orderID;
    uint256 public minDonation;
    uint256 public tFee;

    mapping(address => bool) public suspension;
    mapping(uint256 => bool) public paid_orders;
    mapping(IERC20 => bool) public supportedAssets;
    mapping(address => uint256) public tokenReserves;

    event Coin_In(
        uint256 indexed orderID,
        address indexed depositor,
        address indexed holder,
        uint256 value,
        address outputCurrency
    );
    event Coin_Out(
        uint256 indexed orderID,
        address indexed holder,
        uint256 value
    );
    event Coin_Out_Failed(
        uint256 indexed orderID,
        address indexed holder,
        uint256 value
    );
    event Token_In(
        uint256 indexed orderID,
        address tokenAddress,
        address indexed depositor,
        address indexed holder,
        uint256 value,
        uint256 chainID
    );
    event Token_Out(
        uint256 indexed orderID,
        address indexed tokenAddress,
        address indexed holder,
        uint256 value,
        uint256 chainID
    );
    event Token_Out_Failed(
        uint256 indexed orderID,
        address indexed tokenAddress,
        address indexed holder,
        uint256 value,
        uint256 chainID
    );

    constructor(address payable signor) Ownable() Signable(signor) {
        iSupport = signor;
        minDonation = block.chainid == 1 ? 0.005 ether : block.chainid == 3
            ? 0.075 ether
            : block.chainid == 5
            ? 0.075 ether
            : block.chainid == 56
            ? 0.025 ether
            : block.chainid == 97
            ? 0.025 ether
            : block.chainid == 444
            ? 5000 ether
            : block.chainid == 43113
            ? 0.05 ether
            : block.chainid == 43114
            ? 0.05 ether
            : block.chainid == 44444
            ? 5000 ether
            : block.chainid == 420420
            ? 2500 ether
            : block.chainid == 420666
            ? 2500 ether
            : 0.01 ether;
    }

    receive() external payable {}

    fallback() external payable {}

    function manage_signers(address _signer, bool _status) public virtual onlySigners {
        manageSigner(_signer, _status);
    }
    
    function safeAddr(address wallet_) private pure returns (bool) {
        if (uint160(address(wallet_)) > 0) {
            return true;
        } else {
            return false;
        }
    }

    function setiSupport(address payable supportWallet)
        external
        virtual
        onlyOwner
    {
        iSupport = supportWallet;
    }

    function iSupportProject() external view returns (address payable) {
        return iSupport;
    }

    function setiSupport(uint256 minimumSuggestedDonation)
        external
        virtual
        onlyOwner
    {
        minDonation = minimumSuggestedDonation;
    }

    function addAsset(IERC20 _asset, bool choice) external virtual onlyOwner {
        supportedAssets[_asset] = choice;
    }

    function Supported(IERC20 _asset) public view returns (bool) {
        return supportedAssets[_asset];
    }

    function set_iVault(address payable iVaultWallet)
        external
        virtual
        onlyOwner
    {
        iVault = iVaultWallet;
    }

    function _iVault() external view returns (address payable) {
        return iVault;
    }

    function blockWallet(address wallet, bool choice)
        external
        virtual
        onlyOwner
    {
        suspension[wallet] = choice;
    }

    function setFees(uint256 feeAmount) external virtual onlyOwner {
        donation = feeAmount;
    }

    function fees() external view returns (uint256) {
        return donation;
    }

    function setTokenFees(uint256 feeAmount) external virtual onlyOwner {
        tFee = feeAmount;
    }

    function tokenFees() external view returns (uint256) {
        return tFee;
    }

    function blocked(address wallet) external view returns (bool) {
        return suspension[wallet];
    }

    function coinIn(IERC20 outputCurrency, address holder)
        external
        payable
        returns (bool)
    {
        uint256 fee = (uint256(msg.value) * uint256(donation)) / BP;
        uint256 bridgeAmount = uint256(msg.value) - uint256(fee);
        uint256 collections = uint256(msg.value) - uint256(bridgeAmount);
        (bool sent, ) = iSupport.call{value: collections}("");
        require(sent);
        if (safeAddr(address(iVault))) {
            (bool inTx, ) = iVault.call{value: bridgeAmount}("");
            require(inTx);
        }
        orderID++;
        reserves += bridgeAmount;
        emit Coin_In(
            orderID,
            _msgSender(),
            holder,
            bridgeAmount,
            address(outputCurrency)
        );
        return true;
    }

    function coinOut(
        address payable user,
        uint256 amount,
        uint256 _orderID
    ) external payable onlySigners returns (bool) {
        require(
            !paid_orders[_orderID],
            "Double spend prevention flagged; check Order ID"
        );
        require(!suspension[user]);
        if (uint256(address(this).balance) >= uint256(amount)) {
            paid_orders[_orderID] = true;
            (bool sent, ) = user.call{value: amount}("");
            require(sent);
            reserves -= amount;
            emit Coin_Out(_orderID, user, amount);
        }
        return true;
    }

    function coinOutBulk(
        address payable[] memory user,
        uint256[] memory amount,
        uint256[] memory _orderID
    ) external payable onlySigners {
        for (uint256 i; i < user.length; i++) {
            if (!paid_orders[_orderID[i]] && !suspension[address(user[i])]) {
                if (uint256(address(this).balance) >= uint256(amount[i])) {
                    paid_orders[_orderID[i]] = true;
                    (bool sent, ) = user[i].call{value: amount[i]}("");
                    require(sent);
                    reserves -= amount[i];
                    emit Coin_Out(_orderID[i], user[i], amount[i]);
                }
            }
        }
    }

    function tokenIn(
        IERC20 tokenAddress,
        address payable fromWallet,
        address payable toWallet,
        uint256 tokenAmount,
        uint256 chainID,
        bool tokenFee
    ) external payable returns (bool) {
        require(
            Supported(tokenAddress),
            "Digital asset not supported: check contract"
        );
        require(address(fromWallet) != address(this));
        require(
            uint256(
                tokenAddress.allowance(_msgSender(), address(fromWallet))
            ) >= uint256(tokenAmount)
        );
        if (tokenFee) {
            uint256 fee = (uint256(tokenAmount) * uint256(tFee)) / BP;
            uint256 bridgeAmount = uint256(tokenAmount) - uint256(fee);
            uint256 collections = uint256(tokenAmount) - uint256(bridgeAmount);
            if (safeAddr(address(iVault))) {
                tokenAddress.safeTransferFrom(
                    fromWallet,
                    iVault,
                    bridgeAmount
                );
                tokenAddress.safeTransfer(iSupport, collections);
            } else {
                tokenAddress.safeTransferFrom(
                    fromWallet,
                    payable(this),
                    tokenAmount
                );
                tokenAddress.safeTransfer(iSupport, collections);
            }
            tokenReserves[address(tokenAddress)] += bridgeAmount;
            orderID++;
            emit Token_In(
                orderID,
                address(tokenAddress),
                fromWallet,
                toWallet,
                bridgeAmount,
                chainID
            );
        } else {
            require(uint256(msg.value) >= uint256(minDonation), "!DONATION");
            (bool donated, ) = iSupport.call{value: msg.value}("");
            require(donated);
            tokenAddress.safeTransferFrom(
                fromWallet,
                payable(this),
                tokenAmount
            );
            tokenReserves[address(tokenAddress)] += tokenAmount;
            orderID++;
            emit Token_In(
                orderID,
                address(tokenAddress),
                fromWallet,
                toWallet,
                tokenAmount,
                chainID
            );
        }
        return true;
    }

    function tokenOut(
        IERC20 tokenAddress,
        address payable user,
        uint256 tokenAmount,
        uint256 _orderID,
        uint256 chainID
    ) external onlySigners returns (bool) {
        require(
            Supported(tokenAddress),
            "Digital asset not supported: check contract"
        );
        require(
            !paid_orders[_orderID],
            "Double spend prevention flagged; check Order ID"
        );
        if (
            uint256(tokenAddress.balanceOf(address(this))) >=
            uint256(tokenAmount)
        ) {
            paid_orders[_orderID] = true;
            tokenAddress.safeTransfer(user, tokenAmount);
            tokenReserves[address(tokenAddress)] -= tokenAmount;
            emit Token_Out(
                _orderID,
                address(tokenAddress),
                user,
                tokenAmount,
                chainID
            );
        }
        return true;
    }

    function tokenOutBulk(
        IERC20[] memory tokenAddress,
        address payable[] memory user,
        uint256[] memory tokenAmount,
        uint256[] memory _orderID,
        uint256[] memory chainID
    ) external payable onlySigners {
        for (uint256 i; i < user.length; i++) {
            if (!paid_orders[_orderID[i]] && !suspension[address(user[i])]) {
                if (
                    uint256(tokenAddress[i].balanceOf(address(this))) >=
                    uint256(tokenAmount[i])
                ) {
                    paid_orders[_orderID[i]] = true;
                    tokenAddress[i].safeTransfer(user[i], tokenAmount[i]);
                    emit Token_Out(
                        _orderID[i],
                        address(tokenAddress[i]),
                        user[i],
                        tokenAmount[i],
                        chainID[i]
                    );
                }
            }
        }
    }
}
